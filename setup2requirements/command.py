# -*- coding: utf-8 -*-
"""
Generates a requirements.txt from any packages
in the current working directory.
"""

from __future__ import print_function

import os
import re
import contextlib
import functools
import sys
import setuptools
import pkg_resources
from collections import defaultdict
from distutils import core


class UnspecifiedRequirementError(AssertionError):
    pass


def _assert_requirement_pinned(name, requirement):
    if not requirement.specifier:
        raise UnspecifiedRequirementError(
            'Missing version specifier for requirement {!r} in {!r}'.format(
                requirement.name, name
            )
        )
    return True


def _filter_requirements(
        predicate,
        output,
        name=None,
        install_requires=None,
        extras_require=None,
        dependency_links=None,
        *_args, **_kwargs
):
    if install_requires:
        output[name].update(
            str(requirement) for requirement in
            pkg_resources.parse_requirements(install_requires)
            if predicate(name, requirement, extra=None)
        )

    if dependency_links:
        output[name].update(dependency_links)

    if extras_require:
        for extra, requirements in extras_require.items():
            output[name].update(
                str(requirement) for requirement in
                pkg_resources.parse_requirements(requirements)
                if predicate(name, requirement, extra=extra)
            )


@contextlib.contextmanager
def patch(target, attr, fn):
    """
    Replace a function for the duration of the context manager
    """
    original = getattr(target, attr)
    try:
        setattr(target, attr, fn)
        yield
    finally:
        setattr(target, attr, original)


def find_requirements(predicate, *paths):
    """
    Return the list of requirements for a setup.py
    """
    requirements = defaultdict(set)

    setup = functools.partial(
        _filter_requirements, predicate, requirements
    )

    for path in paths:
        with patch(setuptools, 'setup', setup):
            with open(path, 'r') as handle:
                exec(
                    handle.read(),
                    {'__file__': os.path.realpath(path)},
                    None
                )

    return dict(requirements)


class requirements(core.Command):
    user_options = [
        ('not-strict', None, "Do not force every dependency to have a pinned version number."),
        ('extras=', None, "Generate a requirements.txt that includes extras."),
        ('only-extras', None, 'Generate a requirements.txt that only includes extras'),
        ('output=', None, 'Target output [requirements.txt]'),
        ('allow-empty', None, 'Allow empty requirements.txt'),
    ]
    description = "Run sphinx apidoc, then build the result."

    def initialize_options(self):
        self.extras = []
        self.only_extras = False
        self.not_strict = False
        self.output = 'requirements.txt'
        self.allow_empty = False

    def finalize_options(self):
        if self.extras:
            self.extras = re.split(',\s*', self.extras)

    def run(self):
        def predicate(path, requirement, extra):
            return (
                (self.not_strict or _assert_requirement_pinned(path, requirement)) and (
                    (not extra or self.extras) and
                    (not self.only_extras or extra in self.extras)
                )
            )

        requirements = find_requirements(
            predicate,
            'setup.py'
        )

        dependencies = sorted(
            {
                dependency
                for dependencies in requirements.values()
                for dependency in dependencies
            },
            key=str.lower
        )

        if not dependencies and not self.allow_empty:
            print('No dependencies found.', sys.stderr)
            sys.exit(3)

        @contextlib.contextmanager
        def output():
            if self.output == '-':
                yield sys.stdout
            else:
                with open(self.output, 'w+') as handle:
                    yield handle

        with output() as handle:
            print("""#
# autogenerated by setup2requirements
#
# from:
#
#  {}
#
    """.format('\n#  '.join('* {}'.format(name) for name in requirements)), file=handle)
            for requirement in dependencies:
                print(requirement, file=handle)
